<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>数据搜索和筛选之正则表达式 | 好记性不如烂笔头</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据搜索和筛选之正则表达式</h1><a id="logo" href="/.">好记性不如烂笔头</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">数据搜索和筛选之正则表达式</h1><div class="post-meta">May 26, 2016</div><div class="post-content"><p>正则表达式</p>
<p>正则表达式库在使用之前必须先导入到程序中。正则表达式库最简单的用法是search()函数。搜索函数的简单用法如下程序所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">hand = open(&apos;mbox-short.txt&apos;)</span><br><span class="line">for line in hand:</span><br><span class="line">    line = line.rstrip()</span><br><span class="line">    if re.search(&apos;From:&apos;, line) :</span><br><span class="line">        print line</span><br></pre></td></tr></table></figure>
<p>打开文件，循环每一行，使用正则表达式的search()函数，打印出包含字符串”From:”的文本行。这个程序其实并没有发挥正则表达式的真正实力，line.find()函数可以更容易地实现相同的结果。</p>
<p>正则表达式的强大之处体现于，可以在搜索字符串中添加特定字符，以实现更精确的字符串文本行的匹配控制。通过在正则表达式中添加特定字符，编写很少代码就可以实现复杂的匹配与抽取。</p>
<p>例如，正则表达式的^符号匹配一行的开始。我们修改一下上面的程序，仅匹配“From:”开头的文本行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">hand = open(&apos;mbox-short.txt&apos;)</span><br><span class="line">for line in hand:</span><br><span class="line">    line = line.rstrip()</span><br><span class="line">    if re.search(&apos;^From:&apos;, line) :</span><br><span class="line">        print line</span><br></pre></td></tr></table></figure>
<p>好了，这就做到仅匹配“From:”开头的文本行。这仍然是一个非常简单的例子，字符串库的startswith()函数同样可以实现。之所以这样讲解，目的是介绍正则表达式的理念，包含特定行动字符，给予文本匹配更多的控制。&lt;</p>
<a id="more"></a>
<p>1.1 正则表达式的字符匹配</p>
<p>许多特定字符可以帮助我们编写非常强大的正则表达式。最常用的特定字符是句点，它可以匹配所有字符。</p>
<p>在下面的例子中，正则表达式”F..m:”会匹配配“From:”、”Fxxm”、“F12m”或”Fl@m”。正则表达式的句点可以匹配任意字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">hand = open(&apos;mbox-short.txt&apos;)</span><br><span class="line">for line in hand:</span><br><span class="line">    line = line.rstrip()</span><br><span class="line">    if re.search(&apos;^F..m:&apos;, line) :</span><br><span class="line">        print line</span><br></pre></td></tr></table></figure></p>
<p>“”和“+”表示一个字符可以重复任意次数，在构造正则表达式时结合这种能力特别有用。这些特定字符用来代替单个字符，星号匹配零或多个字符，加号匹配一个或多个字符。</p>
<p>进一步减少代码，以下示例使用重复的通配符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">hand = open(‘mbox-short.txt’)</span><br><span class="line">for line in hand:</span><br><span class="line">    line = line.rstrip()</span><br><span class="line">    if re.search(‘^From:.+@’, line) :</span><br><span class="line">    print line</span><br></pre></td></tr></table></figure>
<p>搜索字符串“^From:.+@”会成功匹配以“From:”开头，之后一个或多个字符，以@结尾的文本行。结果匹配如下所示：</p>
<p>From: stephen.marquard @uct.ac.za<br>可以这样理解，“.+”通配符匹配了冒号与@之间的所有字符。</p>
<p> From:.+ @<br>有时候，加号与星号可能会“用力过猛”。例如下面的字符串匹配，”.+”将其外推，直到最后一个@。</p>
<p>From: <a href="mailto:stephen.marquard@uct.ac.za" target="_blank" rel="noopener">stephen.marquard@uct.ac.za</a>, <a href="mailto:csev@umich.edu" target="_blank" rel="noopener">csev@umich.edu</a>, and cwen @iupui.edu<br>通过添加其他字符，让星号和加号不要如此“贪婪”地匹配，这是可以做到的。。</p>
<p>1.2 使用正则表达式抽取数据</p>
<p>在Python中抽取字符串的数据，用到的是findall()函数。通过正则表达式的匹配，抽取所有符合的子字符串。以下示例从格式无关的任何文本行中抽取类似电子邮件地址的文本。</p>
<p>From <a href="mailto:stephen.marquard@uct.ac.za" target="_blank" rel="noopener">stephen.marquard@uct.ac.za</a> Sat Jan  5 09:14:16 2008<br>Return-Path: <a href="mailto:&#x70;&#111;&#x73;&#116;&#109;&#97;&#115;&#116;&#x65;&#114;&#x40;&#x63;&#x6f;&#108;&#108;&#97;&#98;&#x2e;&#115;&#97;&#x6b;&#97;&#x69;&#112;&#x72;&#x6f;&#x6a;&#x65;&#99;&#116;&#x2e;&#111;&#x72;&#x67;" target="_blank" rel="noopener">&#x70;&#111;&#x73;&#116;&#109;&#97;&#115;&#116;&#x65;&#114;&#x40;&#x63;&#x6f;&#108;&#108;&#97;&#98;&#x2e;&#115;&#97;&#x6b;&#97;&#x69;&#112;&#x72;&#x6f;&#x6a;&#x65;&#99;&#116;&#x2e;&#111;&#x72;&#x67;</a><br>          for <a href="mailto:&#x73;&#111;&#117;&#114;&#99;&#101;&#64;&#99;&#111;&#108;&#108;&#97;&#x62;&#46;&#115;&#97;&#107;&#97;&#x69;&#x70;&#114;&#x6f;&#106;&#101;&#99;&#116;&#x2e;&#x6f;&#114;&#x67;" target="_blank" rel="noopener">&#x73;&#111;&#117;&#114;&#99;&#101;&#64;&#99;&#111;&#108;&#108;&#97;&#x62;&#46;&#115;&#97;&#107;&#97;&#x69;&#x70;&#114;&#x6f;&#106;&#101;&#99;&#116;&#x2e;&#x6f;&#114;&#x67;</a>;<br>Received: (from apache@localhost)<br>Author: <a href="mailto:stephen.marquard@uct.ac.za" target="_blank" rel="noopener">stephen.marquard@uct.ac.za</a><br>我们不想为每个文本行类型编写代码，每个文本行都分割和切片一次。以下程序使用findall()找到文本中的电子邮件地址，从每一行抽取一个或多个电子邮件地址。</p>
<p>import re<br>s = ‘Hello from <a href="mailto:csev@umich.edu" target="_blank" rel="noopener">csev@umich.edu</a> to <a href="mailto:cwen@iupui.edu" target="_blank" rel="noopener">cwen@iupui.edu</a> about the meeting @2PM’<br>lst = re.findall(‘\S+@\S+’, s)<br>print lst<br>findall()函数搜索第二个参数的字符串，返回一个包含形如电子邮件地址字符串的列表。我们使用两字符序列来匹配非空字符(\S)。</p>
<p>程序运行结果如下：</p>
<p>[‘<a href="mailto:csev@umich.edu" target="_blank" rel="noopener">csev@umich.edu</a>’, ‘<a href="mailto:cwen@iupui.edu" target="_blank" rel="noopener">cwen@iupui.edu</a>’]<br>解释一下这个正则表达式，我们寻找至少含有一个非空字符的子字符串，之后是@，然后再是至少一个或多个非空字符。“\S+”匹配尽可能多个非空字符。这就是正则表达式中的贪婪匹配。</p>
<p>正则表达式会匹配两个电子邮件地址，但不会匹配“@2PM”，原因是@之前没有非空字符。在程序中使用这个正则表达式，读取文件的所有行，然后打印出所有类似电子邮件地址的结果，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">hand = open(‘mbox-short.txt’)</span><br><span class="line">for line in hand:</span><br><span class="line">    line = line.rstrip()</span><br><span class="line">    x = re.findall(‘\S+@\S+’, line)</span><br><span class="line">    if len(x) &gt; 0 :</span><br><span class="line">    print x</span><br></pre></td></tr></table></figure>
<p>读取每一行，抽取与正则表达式匹配的所有字符串。由于findall()返回的是列表，我们简单查看下返回的列表不为零，打印出来的每行至少包含一个电子邮件地址。</p>
<h2 id="对mbox-txt运行程序，得到如下结果："><a href="#对mbox-txt运行程序，得到如下结果：" class="headerlink" title="对mbox.txt运行程序，得到如下结果："></a>对mbox.txt运行程序，得到如下结果：</h2><p>[‘<a href="mailto:wagnermr@iupui.edu" target="_blank" rel="noopener">wagnermr@iupui.edu</a>’]<br>[‘<a href="mailto:cwen@iupui.edu" target="_blank" rel="noopener">cwen@iupui.edu</a>’]<br>[‘<a href="mailto:&#x70;&#x6f;&#x73;&#116;&#x6d;&#97;&#x73;&#116;&#101;&#114;&#x40;&#99;&#111;&#x6c;&#x6c;&#x61;&#x62;&#46;&#x73;&#97;&#x6b;&#97;&#x69;&#112;&#114;&#111;&#x6a;&#101;&#x63;&#116;&#x2e;&#x6f;&#x72;&#x67;" target="_blank" rel="noopener">&#x70;&#x6f;&#x73;&#116;&#x6d;&#97;&#x73;&#116;&#101;&#114;&#x40;&#99;&#111;&#x6c;&#x6c;&#x61;&#x62;&#46;&#x73;&#97;&#x6b;&#97;&#x69;&#112;&#114;&#111;&#x6a;&#101;&#x63;&#116;&#x2e;&#x6f;&#x72;&#x67;</a>’]<br>[‘<a href="mailto:&#x32;&#x30;&#x30;&#56;&#48;&#x31;&#x30;&#51;&#x32;&#49;&#50;&#x32;&#46;&#x6d;&#x30;&#51;&#x4c;&#x4d;&#70;&#111;&#52;&#x30;&#x30;&#x35;&#49;&#52;&#x38;&#64;&#x6e;&#97;&#107;&#97;&#109;&#117;&#114;&#x61;&#x2e;&#x75;&#x69;&#116;&#x73;&#46;&#x69;&#117;&#x70;&#117;&#x69;&#46;&#x65;&#x64;&#x75;" target="_blank" rel="noopener">&#x32;&#x30;&#x30;&#56;&#48;&#x31;&#x30;&#51;&#x32;&#49;&#50;&#x32;&#46;&#x6d;&#x30;&#51;&#x4c;&#x4d;&#70;&#111;&#52;&#x30;&#x30;&#x35;&#49;&#52;&#x38;&#64;&#x6e;&#97;&#107;&#97;&#109;&#117;&#114;&#x61;&#x2e;&#x75;&#x69;&#116;&#x73;&#46;&#x69;&#117;&#x70;&#117;&#x69;&#46;&#x65;&#x64;&#x75;</a>’]<br>[‘<a href="mailto:&#115;&#x6f;&#117;&#114;&#x63;&#101;&#64;&#x63;&#111;&#x6c;&#108;&#x61;&#98;&#46;&#115;&#97;&#107;&#x61;&#105;&#x70;&#x72;&#x6f;&#106;&#101;&#99;&#x74;&#x2e;&#x6f;&#114;&#x67;" target="_blank" rel="noopener">&#115;&#x6f;&#117;&#114;&#x63;&#101;&#64;&#x63;&#111;&#x6c;&#108;&#x61;&#98;&#46;&#115;&#97;&#107;&#x61;&#105;&#x70;&#x72;&#x6f;&#106;&#101;&#99;&#x74;&#x2e;&#x6f;&#114;&#x67;</a>;’]<br>[‘<a href="mailto:&#x73;&#x6f;&#117;&#x72;&#x63;&#x65;&#64;&#x63;&#111;&#x6c;&#108;&#97;&#98;&#x2e;&#115;&#97;&#107;&#97;&#x69;&#x70;&#114;&#x6f;&#106;&#101;&#99;&#x74;&#x2e;&#x6f;&#114;&#x67;" target="_blank" rel="noopener">&#x73;&#x6f;&#117;&#x72;&#x63;&#x65;&#64;&#x63;&#111;&#x6c;&#108;&#97;&#98;&#x2e;&#115;&#97;&#107;&#97;&#x69;&#x70;&#114;&#x6f;&#106;&#101;&#99;&#x74;&#x2e;&#x6f;&#114;&#x67;</a>;’]<br>[‘<a href="mailto:&#x73;&#x6f;&#117;&#x72;&#99;&#101;&#64;&#99;&#x6f;&#108;&#108;&#97;&#x62;&#x2e;&#115;&#x61;&#x6b;&#97;&#x69;&#x70;&#114;&#x6f;&#106;&#101;&#99;&#116;&#46;&#111;&#x72;&#103;" target="_blank" rel="noopener">&#x73;&#x6f;&#117;&#x72;&#99;&#101;&#64;&#99;&#x6f;&#108;&#108;&#97;&#x62;&#x2e;&#115;&#x61;&#x6b;&#97;&#x69;&#x70;&#114;&#x6f;&#106;&#101;&#99;&#116;&#46;&#111;&#x72;&#103;</a>;’]<br>[‘apache@localhost]’]<br>[‘<a href="mailto:source@collab.sakaiproject.org" target="_blank" rel="noopener">source@collab.sakaiproject.org</a>;’]<br>一些电子地址的开头或结尾包含了不正确的字符，如“&lt;”或“;”。这里声明一下，仅需要以字母或数字开头和结尾的字符串部分。</p>
<p>要做到这一点，我们使用正则表达式的另一个功能，使用方括号罗列多个可接受的匹配字符。在某种意义上，“\S”匹配的是非空字符的集合。现在，我们更清楚一些字符匹配的本质了。</p>
<p>下面是新的正则表达式：</p>
<p>[a-zA-Z0-9]\S@\S[a-zA-Z]<br>这看起来有点复杂，你现在应该明白正则表达式为什么被称为一门专门的语言了。解释一下这个正则表达式，寻找以一种子字符串，以小写字母、大写字母或数字开头[a-zA-Z0-9]，之后是零个或多个非空字符“\S”，然后是@，再是零个或多个非空字符“\S”，最后是一个大写或小写字母。请注意，我们从加号到星号，再到零个或多个非空字符。[a-zA-Z0-9]本身就是一个非空字符。请记住，星号和加号直接作用于它左侧的单个字符。</p>
<p>如果在程序中使用这个正则表达式，数据会变得干净一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">hand = open(‘mbox-short.txt’)</span><br><span class="line">for line in hand:</span><br><span class="line">    line = line.rstrip()</span><br><span class="line">    x = re.findall(‘[a-zA-Z0-9]\S@\S[a-zA-Z]’, line)</span><br><span class="line">    if len(x) &gt; 0 :</span><br><span class="line">        print x</span><br><span class="line">…</span><br><span class="line">[‘wagnermr@iupui.edu’]</span><br><span class="line">[‘cwen@iupui.edu’]</span><br><span class="line">[‘postmaster@collab.sakaiproject.org’]</span><br><span class="line">[‘200801032122.m03LMFo4005148@nakamura.uits.iupui.edu’]</span><br><span class="line">[‘source@collab.sakaiproject.org’]</span><br><span class="line">[‘source@collab.sakaiproject.org’]</span><br><span class="line">[‘source@collab.sakaiproject.org’]</span><br><span class="line">[‘apache@localhost’]</span><br></pre></td></tr></table></figure>
<p>注意到<a href="mailto:source@collab.sakaiproject.org" target="_blank" rel="noopener">source@collab.sakaiproject.org</a>这一行，正则表达式消除了字符串结尾（“&gt;”）结尾的两个字母。原因是我们在正则表达式末尾追加了“[a-zA-Z]”，要求正则表达式解析器对找到的字符串必须以字母结尾。因此，当出现“sakaiproject.org&gt;;” ，它会止步于匹配找到的最后一个字母，这里g是最后一个符合要求的字符匹配。</p>
<p>还要注意的是，该程序的结果是一个Python列表，每个字符串是一个元素。</p>
<p>1.3 将搜索与抽取结合</p>
<p>如果我们想要找到以“X-”开头的文本行，如下所示：</p>
<p>X-DSPAM-Confidence: 0.8475<br>X-DSPAM-Probability: 0.0000<br>我们不仅需要文本行中的浮点数，还需要统计符合以上语法的文本行数。</p>
<p>使用下面的正则表达式来挑选出符合要求的文本行：</p>
<p>^X-.: [0-9.]+<br>解释一下，文本以“X-”开头，之后是零个或多个字符“.”，然后是一个冒号和一个空格。空格之后是一个或多个字符，可以是一个数字(0-9)或一个句点“[0-9.]+”。需要注意的是，方括号中的句点实际匹配的是句点本身，也就是说，它在方括号内不是通配符。</p>
<p>这是一个非常紧凑的表达式，我们感兴趣的文本匹配如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">hand = open(‘mbox-short.txt’)</span><br><span class="line">for line in hand:</span><br><span class="line">    line = line.rstrip()</span><br><span class="line">    if re.search(‘^X\S: [0-9.]+’, line) :</span><br><span class="line">        print line</span><br></pre></td></tr></table></figure>
<p>运行这个程序，经过过滤的数据仅保留如下内容：</p>
<p>X-DSPAM-Confidence: 0.8475<br>X-DSPAM-Probability: 0.0000<br>X-DSPAM-Confidence: 0.6178<br>X-DSPAM-Probability: 0.0000<br>现在，我们要解决抽取数值的问题，使用split方法。虽然使用split很简单，我们这里使用正则表达式的另一个功能，让搜索与解析同时进行。</p>
<p>括号是正则表达式的另一个特殊字符。在正则表达式中添加括号，括号的内容将在匹配时被忽略。但是，在 findall()函数中括号表示的是匹配括号内的整个表达式。在抽取与正则表达式匹配的子字符串部分，findall()函数适用。</p>
<p>这样，修改之后的程序代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">hand = open(‘mbox-short.txt’)</span><br><span class="line">for line in hand:</span><br><span class="line">    line = line.rstrip()</span><br><span class="line">    x = re.findall(‘^X\S: ([0-9.]+)’, line)</span><br><span class="line">    if len(x) &gt; 0 :</span><br><span class="line">        print x</span><br></pre></td></tr></table></figure>
<p>与search()函数不同，我们在正则表达式中添加括号来表示浮点数，指明我们只需要findall()函数找出匹配到的字符串的浮点数。</p>
<p>程序运行结果如下：</p>
<p>[‘0.8475’]<br>[‘0.0000’]<br>[‘0.6178’]<br>[‘0.0000’]<br>[‘0.6961’]<br>[‘0.0000’]<br>数字仍然是存在列表中，需要把字符串转换为浮点数。这里侧重展示正则表达式可以同时进行搜索与抽取的功能实现。</p>
<p>如果文件包含如下形式的文本行，使用这种方法的另一个例子如下：</p>
<p>Details: <a href="http://source.sakaiproject.org/viewsvn/?view=rev&amp;rev=39772" target="_blank" rel="noopener">http://source.sakaiproject.org/viewsvn/?view=rev&amp;rev=39772</a><br>如果想要抽取所有的修订号（每一行末尾的整数值），程序代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">hand = open(‘mbox-short.txt’)</span><br><span class="line">for line in hand:</span><br><span class="line">    line = line.rstrip()</span><br><span class="line">    x = re.findall(‘^Details:.rev=([0-9]+)’, line)</span><br><span class="line">    if len(x) &gt; 0:</span><br><span class="line">        print x</span><br></pre></td></tr></table></figure>
<p>解释一下这个正则表达式，以“Details:”开头，之后是任意字符“.”，然后是“rev=”，最后是零或多个数字。我们只需要文本行最后的整数值，所以用括号把[0-9]+括起来。</p>
<p>程序运行结果如下：</p>
<p>[‘39772’]<br>[‘39771’]<br>[‘39770’]<br>[‘39769’]<br>…<br>请记住，“[0-9]+”是“贪婪的”，在抽取这些数字之前，它试图匹配尽可能多的符合条件的字符串。这个贪婪行为是获得5位数字的原因所在。正则表达式库进行了前后扩展，直到它在开头或结尾遇到一个非数字才停止匹配。</p>
<p>现在，我们可以使用正则表达式重做之前的邮件消息中的时间提取。文本内容如下：</p>
<p>From <a href="mailto:stephen.marquard@uct.ac.za" target="_blank" rel="noopener">stephen.marquard@uct.ac.za</a> Sat Jan  5 09:14:16 2008<br>此处抽取每一行中当天的小时。之前的做法是调用split两次。第一次，文本行分解为单词，取出第五个单词，将其再次用冒号分解。最后，取出我们需要的前两个字符。</p>
<p>虽然这样做达到了目标，但在代码编写时缺乏一定灵活性，前提是文本需要经过良好的格式化。如果增加足够的错误检查或一大块的try/except代码，确保程序在遇到格式不正确的文本行时不会出错，代码会增长到10-15行，那就不太好阅读了。</p>
<p>使用下面的正则表达式可以更容易地做到这一点：</p>
<p>^From . [0-9][0-9]:<br>解释一下这个正则表达式，以“From ”开头（注意空格），之后是任意多个字符“.”，然后空一格，接着是2位数字“[0-9][0-9]”，最后是一个冒号。这样的定义符合之前想要寻找的内容。</p>
<p>为了只取出小时数，使用findall()方法，在两位数字上加括号，正则表达式如下：</p>
<p>^From . ([0-9][0-9]):<br>程序代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">hand = open(‘mbox-short.txt’)</span><br><span class="line">for line in hand:</span><br><span class="line">    line = line.rstrip()</span><br><span class="line">    x = re.findall(‘^From . ([0-9][0-9]):’, line)</span><br><span class="line">    if len(x) &gt; 0 : print x</span><br></pre></td></tr></table></figure>
<p>程序运行结果如下：</p>
<p>[‘09’]<br>[‘18’]<br>[‘16’]<br>[‘15’]<br>…<br>1.4 转义字符</p>
<p>由于在正则表达式中使用特殊字符来匹配一行的开头与结尾，或指定通配符，那么需要一种方法来保证这些特殊字符本身的指代性，例如匹配$与^符号本身。通过在字符前使用反斜杠作为前缀可以轻松解决这个问题。例如，使用以下正则表达式找出金额数。</p>
<p>import re<br>x = ‘We just received $10.00 for cookies.’<br>y = re.findall(‘\$[0-9.]+’,x)<br>由于$符号之前有一个反斜杠，它实际上匹配的是美元符号本身，不是匹配一行的结尾，正则表达式的其他部分匹配一个或多个数字和句点。请注意，方括号内，字符没有特殊性。因此，[0-9.]实际表示数字和句点。方括号之外，句点是一个通配符，匹配任意字符。在方括号之内，句点就代表它本身。</p>
<p>1.5 小结</p>
<p>虽然本章只触及了正则表达式的皮毛，但我们已经对正则表达式这门语言有所了解。包含特殊字符的搜索字符串能够按照意愿，构建正则表达式来定义匹配的字符和想要抽取的内容。以下是一些特殊字符和字符序列：</p>
<p>^ 匹配文本行的开头。</p>
<p>$ 匹配文本行的结尾。</p>
<p>. 匹配任一字符（一个通配符）。</p>
<p>\s 匹配一个空白字符。</p>
<p>\S 匹配一个非空字符（与\s相反）。</p>
<p>应用于前接字符，表示前接字符的零个或多个匹配。</p>
<p>*? 应用于前接字符，以非贪婪模式，表示前接字符的零个或多个匹配。</p>
<ul>
<li>应用于前接字符，表示前接字符的一个或多个匹配。</li>
</ul>
<p>+? 应用于前接字符，以非贪婪模式，表示前接字符的一个或多个匹配。</p>
<p>[aeiou] 匹配指定字符集中的一个字符。这里只能是“a”、“e”、 “i”、 “o”或 “u”，不接受其他字符。</p>
<p>[a-z0-9] 使用减号指定字符区间。这里表示一个字符，必须是小写字母或数字。</p>
<p>[^A-Za-z] 第一个字符是^，它表示反向逻辑。这里匹配除了大小写字符之外的其他任意字符。</p>
<p>( )在正则表达式中添加括号，括号内容会丧失匹配功能，但在findall()中可以用于抽取特定部分的字符串，而不是整个字符串。</p>
<p>\b 匹配空字符串，仅用于单词的首尾。</p>
<p>\B 匹配空字符串，但不能用于单词的首尾。</p>
<p>\d 匹配任意十进制数字，等价于[0-9]。</p>
<p>\D 匹配任意非数字字符，等价于0-9。</p>
<p>1.6 Unix用户福利</p>
<p>自20世纪60年以后，Unix操作系统内置了文件搜索的正则表达式功能。它几乎在所有编程语言中通用，只是细节上有所差别。</p>
<p>事实上，Unix内置了一个命令行工具，称为grep（Generalized Regular Expression Parser，通用正则表达式解析器），可以实现本章search()在示例中的相同作用。如果使用Mac或Linux操作系统，你可以在命令行窗口中执行以下语句。</p>
<p>$ grep ‘^From:’ mbox-short.txt<br>From: <a href="mailto:stephen.marquard@uct.ac.za" target="_blank" rel="noopener">stephen.marquard@uct.ac.za</a><br>From: <a href="mailto:louis@media.berkeley.edu" target="_blank" rel="noopener">louis@media.berkeley.edu</a><br>From: <a href="mailto:zqian@umich.edu" target="_blank" rel="noopener">zqian@umich.edu</a><br>From: <a href="mailto:rjlowe@iupui.edu" target="_blank" rel="noopener">rjlowe@iupui.edu</a><br>这条命令告诉grep，显示mbox-short.txt文件中以“From:”开头的字符串。如果尝试使用grep命令和阅读grep的文档，你会发现Python支持的正则表达式与grep支持的正则表达式存在一些细微差别。例如，grep不支持非空字符“\S”，所以需要使用稍微复杂一点的集合符号“[^ ]”，表示匹配非空格的任意字符。gggg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 应用于前接字符，表示前接字符的零个或多个匹配。</span><br><span class="line">+ 应用于前接字符，表示前接字符的一个或多个匹配。</span><br><span class="line"></span><br><span class="line">*? 应用于前接字符，以非贪婪模式，表示前接字符的零个或多个匹配。+</span><br><span class="line">+? 应用于前接字符，以非贪婪模式，表示前接字符的一个或多个匹配。</span><br><span class="line"></span><br><span class="line">非贪婪和贪婪就是使用零个,一个,而不是有多个.</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/Spider/">Spider</a></div><div class="post-nav"><a class="pre" href="/2016/06/17/Xpath/">Xpath</a><a class="next" href="/2016/05/04/aptitude/">Ubuntu(Debian)的aptitude与apt-get的区别和联系</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://iusepython.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/FrontEnd/">FrontEnd</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frontend/">Frontend</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spider/">Spider</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Database/" style="font-size: 15px;">Database</a> <a href="/tags/Web/" style="font-size: 15px;">Web</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/FrontEnd/" style="font-size: 15px;">FrontEnd</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Deploy/" style="font-size: 15px;">Deploy</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Ubuntu/" style="font-size: 15px;">Ubuntu</a> <a href="/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/IDE/" style="font-size: 15px;">IDE</a> <a href="/tags/Frontend/" style="font-size: 15px;">Frontend</a> <a href="/tags/Virtualenv/" style="font-size: 15px;">Virtualenv</a> <a href="/tags/sqlalchemy/" style="font-size: 15px;">sqlalchemy</a> <a href="/tags/flask/" style="font-size: 15px;">flask</a> <a href="/tags/Html/" style="font-size: 15px;">Html</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/node-js/" style="font-size: 15px;">node.js</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Spider/" style="font-size: 15px;">Spider</a> <a href="/tags/Vim/" style="font-size: 15px;">Vim</a> <a href="/tags/Webpack/" style="font-size: 15px;">Webpack</a> <a href="/tags/zsh/" style="font-size: 15px;">zsh</a> <a href="/tags/English/" style="font-size: 15px;">English</a> <a href="/tags/Others/" style="font-size: 15px;">Others</a> <a href="/tags/DA/" style="font-size: 15px;">DA</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/17/Git Rebase/">Git Rebase</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/04/Python类中使用-call/">Python类中使用__call__</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/02/Sqlalchemy/">Sqlalchemy</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/04/Python-try-except-else/">Python_try_except_else</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/04/Python的-str/">Python的__str__</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/27/数据分析相关概念整理/">数据分析相关概念整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/18/Python私有变量/">Python私有变量</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/17/Ubuntu系统崩溃问题/">Ubuntu系统崩溃问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/16/Python的-init-文件/">Python的__init__文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/11/API/">API</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://github.com/fanhaipeng0403" title="Github" target="_blank">Github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">好记性不如烂笔头.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>